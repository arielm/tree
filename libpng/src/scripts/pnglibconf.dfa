# scripts/pnglibconf.dfa - library build configuration control
#
@/*- pnglibconf.dfn intermediate file
@ *  generated from scripts/pnglibconf.dfa
@ */
#
com pnglibconf.h - library build configuration
com
version
com
com Copyright (c) 1998-2016 Glenn Randers-Pehrson
com
com This code is released under the libpng license.
com For conditions of distribution and use, see the disclaimer
com and license in png.h
com

file pnglibconf.h scripts/pnglibconf.dfa PNGLCONF_H

# This file is preprocessed by scripts/options.awk and the
# C compiler to generate 'pnglibconf.h' - a list of all the
# configuration options.  The file lists the various options
# that can *only* be specified during the libpng build;
# pnglibconf.h freezes the definitions selected for the specific
# build.
#
# The syntax is detailed in scripts/options.awk; this is a summary
# only:
#
# setting <name> [requires ...] [default]
#    #define PNG_<name> <value>  /* value comes from current setting */
# option <name> [requires ...] [if ...] [enables ...] [disabled]
#    #define PNG_<name>_SUPPORTED if the requirements are met and
#    enable the other options listed
# chunk <name> [requires ...] [enables ...] [disabled]
#    Enable chunk processing for the given ancillary chunk; any
#    'requires something' expands to READ_something for read and
#    WRITE_something for write, but the enables list members are
#    used as given (e.g. enables GAMMA just expands to that on the
#    correspond READ_name and WRITE_name lines.)
#
# "," may be used to separate options on an 'option' line and is ignored; it
# doesn't change the meaning of the line.  (NOT setting, where "," becomes
# part of the setting!)  A comma at the end of an option line causes a
# continuation (the next line is included in the option too.)
#
# Note that the 'on' and 'off' keywords, while valid on both option
# and chunk, should not be used in this file because they force the
# relevant options on or off.

#-------------------------------------------------------------------------------

# The following setting, option and chunk values can all be changed
# while building libpng:
#
# setting: change 'setting' lines to fine tune library performance;
#   changes to the settings don't affect the libpng API functionally
#
# option: change 'option' lines to remove or add capabilities from
#   or to the library; options change the library API
#
# chunk: change 'chunk' lines to remove capabilities to process
#   optional ('ancillary') chunks.  This does not prevent PNG
#   decoding but does change the libpng API because some chunks
#   will be ignored.
#
# There are three ways of disabling features, in order of power:
#
# 1) Write a new '.dfa' file (say 'user.dfa') and in this file
# provide override values for setting entries and turn options or
# chunk values explicitly 'on' or 'off':
#
#    setting FOO default VALUE
#    option BAR [on|off]
#
# Then add this file to the options.awk command line (the *first*
# one) after this file.  The make macro DFA_XTRA is provided to make
# this easier (set it like CPPFLAGS prior to running ./configure).
# Look at the builds below contrib/pngminim for some extreme examples
# of how this can be used.
#
# When you set an option 'off' it will be off; if this is impossible you
# will get an error when you build pnglibconf.h.  If you just want to
# set something off or on if it can be use 'disabled' or 'enabled' instead.
#
# The distributed file "user.dfa" is already included in a configure build
# and you can edit this in place if you are prepared to modify the source.
#
# 2) Create 'pngusr.h', enter the required private build information
# detailed below and #define PNG_NO_<option> for each option you
# want disabled.  You can also enable options using PNG_<option>_SUPPORTED.
# When you have finished rerun configure and rebuild pnglibconf.h file with
# -DPNG_USER_CONFIG:
#
#  make clean
#  CPPFLAGS='-DPNG_USER_CONFIG' ./configure
#  make pnglibconf.h
#
# pngusr.h is only used during the creation of pnglibconf.h, but it
# is safer to ensure that -DPNG_USER_CONFIG is specified throughout
# the build by changing the CPPFLAGS passed to the initial ./configure
#
# 3) Add definitions of the settings you want to change to
# CPPFLAGS; for example:
#
#   -DPNG_DEFAULT_READ_MACROS=0
#   -DPNG_NO_WRITE
#   -DPNG_NO_GET_PALETTE_MAX -DPNG_READ_GET_PALETTE_MAX_SUPPORTED=
#
# As with #defines in pngusr.h these macro settings 'disable' or 'enable' and
# option and they get frozen in pnglibconf.h; read pnglibconf.h to see what
# (if anything) changed.
#
# IMPORTANT: when you pass this to the C compiler:
#
#  -DPNG_foo_SUPPORTED
#
# it is the same as this #define:
#
#  #define PNG_foo_SUPPORTED 1
#
# HOWEVER the macro will be recorded in pnglibconf.h as:
#
#  #define PNG_foo_SUPPORTED
#
# To avoid confusion use -DPNG_foo_SUPPORTED= on the command line, which does
# the same thing as the #define.
#
# SUMMARY:
#  These lines/macro settings are equivalent:
#
#  To 'enable' an option; it will be on if its dependencies are satisfied
#
#     -DPNG_foo_SUPPORTED=        on the CC command line
#     #define PNG_foo_SUPPORTED   in pngusr.h
#     option foo enabled          in user.dfa
#
#  To 'disable' an option; it will be off unless something below enables it:
#
#     -DPNG_NO_foo                on the CC command line
#     #define PNG_NO_foo          in pngusr.h
#     option foo disabled         in user.dfa
#
#  To force an option on; the build of pnglibconf.h will fail if it has
#  unsatisfied dependencies:
#
#     option foo on               in user.dfa
#
#  To force an option off; there is no way to turn it back on, the build of
#  pnglibconf.h will fail if it is required:
#
#     option foo off              in user.dfa
#
# If you want to start with everything 'off' and just turn things on that are
# required (the recommended approach to building a minimal libpng) use user.dfa
# and start with:
#
#     everything off              in user.dfa
#
# This actually *disables* all the options so that they can be enabled either
# explicitly or as required by other options.
#
# Don't edit this file unless you are contributing a patch to # libpng
# and need new or modified options/settings.
#-------------------------------------------------------------------------------

# The following causes commented out #undef lines to be written to
# pnglibconf.h; this can be stopped by logunsupported=0 in a later
# file or on the command line (after pnglibconf.dfa)

logunsupported = 1

# The following allows the output from configure to modify the contents of
# pnglibconf.h

@#ifdef HAVE_CONFIG_H
@#  include "config.h"
@#endif

# PNG_USER_CONFIG has to be defined on the compiler command line
# to cause pngusr.h to be read while constructing pnglibconf.h
#
# If you create a private DLL you need to define the following
# macros in the file 'pngusr.h' and set -DPNG_USER_CONFIG for
# compilation (i.e. in CPPFLAGS.)
# #define PNG_USER_PRIVATEBUILD \
#     <Describes by whom and why this version of the DLL was built>
#  e.g. #define PNG_USER_PRIVATEBUILD "Build by MyCompany for xyz reasons."
# #define PNG_USER_DLLFNAME_POSTFIX <two-letter postfix that serve to
#        distinguish your DLL from those of the official release. These
#        correspond to the trailing letters that come after the version
#        number and must match your private DLL name>
#  e.g. // private DLL "libpng13gx.dll"
#       #define PNG_USER_DLLFNAME_POSTFIX "gx"
#
# The following macros are also at your disposal if you want to complete the
# DLL VERSIONINFO structure.
# - PNG_USER_VERSIONINFO_COMMENTS
# - PNG_USER_VERSIONINFO_COMPANYNAME
# - PNG_USER_VERSIONINFO_LEGALTRADEMARKS

# It is necessary to include configures definitions here so that AC_DEFINE
# in configure.ac works in a comprehensible way
@#if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
@#  include "config.h"
@#endif

@#ifdef PNG_USER_CONFIG
@#  include "pngusr.h"
@#endif

# This is a special fixup for the Watcom C compiler on Windows, which has
# multiple procedure call standards.  Unless PNG_API_RULE is set explicitly
# (i.e. if it is not defined at this point) it will be forced to '2' here when
# using Watcom.  This indicates to the other header files that Watcom behaviour
# is required where appropriate.

@#ifdef __WATCOMC__
@#  ifndef PNG_API_RULE
@#     define PNG_API_RULE 2 /* Use Watcom calling conventions */
@#  endif
@#endif

# IN DEVELOPMENT
# These are currently experimental features; define them if you want (NOTE:
# experimental options must be disabled before they are defined in this file!)

# NONE

# Settings for private builds.  The following two are required:
#
# 1) USER_PRIVATEBUILD: set to the name of the legal entity holding the
#    copyright to the changes (even if the changes are only a local
#    configuration!)
#
# 2) USER_BUG_REPORTS: set to the email to which bug reports relating to this
#    private configuration should be sent.
#
# Note that PNG_USER_CONFIG only has an effect when building pnglibconf.h
setting USER_CONFIG
setting USER_PRIVATEBUILD
setting USER_BUG_REPORTS
setting USER_DLLFNAME_POSTFIX
setting USER_VERSIONINFO_COMMENTS
setting USER_VERSIONINFO_COMPANYNAME
setting USER_VERSIONINFO_LEGALTRADEMARKS

# Record the 'API rule' used to select calling conventions on
# those systems that support such things (see all the comments in
# pngconf.h)
# Changing this setting has a fundamental affect on the PNG ABI,
# do not release shared libraries with this changed.

setting API_RULE default 0

# This allows a prefix to be added to the front of every API functon name (and
# therefore every symbol) by redefining all the function names with the prefix
# at the end of pnglibconf.h.  It also turns on similar internal symbol renaming
# by causing a similar build-time only file, pngprefix.h, to be generated.

setting PREFIX

# This says that a prefix has been added to zlib API function names; at present
# it is informational. The builder of zlib must ensure that zlib.h contains the
# appropriate renames

setting ZLIB_PREFIX

# This is used to select an alternative zlib header file - it must look pretty
# much like the standard zlib.h, but this makes it easier to ensure the correct
# header file is used.  Set it to the "" or <> quoted file name (a full file
# name is acceptable).  Prior to 1.7.0 this used "zlib.h", so it would use a
# zlib.h in the same directory as the libpng source, from 1.7.0 it defaults to
# just searching the -I directories.  Prior to 1.6.0 the #include appeared in
# the exported header files - so it was quite important to use "zlib.h" to
# ensure that applications always got the zlib.h from the same directory as
# png.h.
setting ZLIB_HEADER default <zlib.h>

# Include the zlib header too, so that the defaults below are known
@#  include <zlib.h>

# Implementation specific control of the optimizations, enabled by those
# hardware or software options that need it (typically when run-time choices
# must be made by the user)
option SET_OPTION disabled

# Run-time setting of parameters, enabled as required below
option SETTING disabled

# To support hardware specific optimizations libpng can include a hardware
# specific header at build time, this setting records the included header:
setting EXTENSION_HEADER

# These settings configure the default compression level (0-9) and 'strategy';
# strategy is as defined by the implementors of zlib. It describes the input
# data and modifies the zlib parameters in an attempt to optimize the balance
# between search and huffman encoding in the zlib algorithms.  The defaults are
# the zlib.h defaults - the apparently recursive definition does not arise
# because the name of the setting is prefixed by PNG_
#
# The TEXT values are the defaults when writing compressed text (all forms)

# The '@' here means to substitute the value when pnglibconf.h is built
setting ZLIB_VERNUM default @ZLIB_VERNUM
setting Z_DEFAULT_COMPRESSION default @Z_DEFAULT_COMPRESSION
# TODO: why aren't these Z_RLE; zlib.h says that Z_RLE, specifically, is
# appropriate for PNG images, maybe it doesn't exist in all versions?
setting Z_DEFAULT_STRATEGY default @Z_FILTERED
setting Z_DEFAULT_NOFILTER_STRATEGY default @Z_DEFAULT_STRATEGY

setting TEXT_Z_DEFAULT_COMPRESSION default @Z_DEFAULT_COMPRESSION
setting TEXT_Z_DEFAULT_STRATEGY default @Z_DEFAULT_STRATEGY

# Define this to something that will stop, at least, the current thread; control
# cannot proceed beyond the PNG_ABORT operation and compilation of pngerror.c is
# likely to fail if the operation implemented does not clearly terminate the
# thread or process.  The default implementation is the ANSI-C abort function,
# but any manner of C code may be used.

setting ABORT default { (abort()); }

# Default to using the read macros

setting DEFAULT_READ_MACROS default 1

# The alternative is to call functions to read PNG values, if
# the functions are turned *off* the read macros must always
# be enabled, so turning this off will actually force the
# USE_READ_MACROS option on (see pngconf.h)

option READ_INT_FUNCTIONS requires READ

# The same for write  but these can only be switched off if no writing
# is required at all - hence the use of a 'disabled', not a 'requires'.
# If these are needed, they are enabled in the 'WRITE options' section
# below.

option WRITE_INT_FUNCTIONS disabled

# Error controls
#
# WARNINGS: normally on, if off no warnings are generated
# ERROR_TEXT: normally on, if off errors happen but there is no message
# ERROR_NUMBERS: unimplemented feature, therefore disabled
# BENIGN_ERRORS: support for just issuing warnings for recoverable errors
#
# BENIGN_READ_ERRORS:
#     By default recoverable errors on read should just generate warnings,
#     generally safe but PNG files that don't conform to the specification will
#     be accepted if a meaningful result can be produced.
#
# BENIGN_WRITE_ERRORS:
#     By default recoverable errors on write should just generate warnings,
#     not generally safe because this allows the application to write invalid
#     PNG files.  Applications should enable this themselves; it's useful
#     because it means that a failure to write an ancilliary chunk can often be
#     ignored.

option WARNINGS
option ERROR_TEXT
option ERROR_NUMBERS disabled

option BENIGN_ERRORS
option BENIGN_WRITE_ERRORS requires BENIGN_ERRORS disabled
option BENIGN_READ_ERRORS requires BENIGN_ERRORS


# Generic options - affect both read and write.

# If you want this you need to switch on either the read or write transform
# mechanism, otherwise nothing will happen.
option MNG_FEATURES disabled enables TRANSFORM_MECH
option MNG_READ_FEATURES enables MNG_FEATURES
option MNG_WRITE_FEATURES enables MNG_FEATURES

# Arithmetic options, the first is the big switch that chooses between internal
# floating and fixed point arithmetic implementations - it does not affect any
# APIs.  The second two (the _POINT settings) switch off individual APIs.
#
# Prior to libpng 1.6.8 one of the API (_POINT) variants had to be selected.  At
# 1.6.8 this restriction has been removed; the simplified API can be used
# without enabling any of the low level fixed/floating APIs.

option FLOATING_ARITHMETIC
option FLOATING_POINT
option FIXED_POINT

# This protects us against compilers that run on a windowing system
# and thus don't have or would rather us not use the stdio types:
# stdin, stdout, and stderr.  The only one currently used is stderr
# in png_error() and png_warning().  #defining PNG_NO_CONSOLE_IO will
# prevent these from being compiled and used. #defining PNG_NO_STDIO
# will also prevent these, plus will prevent the entire set of stdio
# macros and functions (FILE *, printf, etc.) from being compiled and used,
# unless (PNG_DEBUG > 0) has been #defined.

option STDIO
option CONSOLE_IO requires STDIO

# Note: prior to 1.5.0 this option could not be disabled if STDIO
# was enabled.  Prior to 1.5.3 this option required STDIO

option TIME_RFC1123

# PNG_SETJMP_NOT_SUPPORTED is an old equivalent for NO_SETJMP

option SETJMP
= NO_SETJMP SETJMP_NOT_SUPPORTED

# If this is disabled it is not possible for apps to get the
# values from the 'info' structure, this effectively removes
# quite a lot of the READ API.

option EASY_ACCESS

# Added at libpng-1.2.0

option USER_MEM

# Added at libpng-1.4.0

option IO_STATE

# Libpng limits: limit the size of images and data on read.
#
# If this option is disabled all the limit checking code will be disabled:

option USER_LIMITS requires READ

# The default settings given below for the limits mean that libpng will
# limit the size of images or the size of data in ancilliary chunks to less
# than the specification or implementation limits. Settings have the
# following interpretations:
#
# USER_WIDTH_MAX: maximum width of an image that will be read
# USER_HEIGHT_MAX: maximum height
# USER_CHUNK_MALLOC_MAX: maximum in-memory (decompressed) size of a single chunk
# USER_CHUNK_CACHE_MAX: maximum number of chunks to be cached
#
# Only chunks that are variable in number are counted towards the
# USER_CHUNK_CACHE_MAX limit

# Use 0x7fffffff for unlimited
setting USER_WIDTH_MAX default        1000000
setting USER_HEIGHT_MAX default       1000000

# Use 0 for unlimited
setting USER_CHUNK_CACHE_MAX default     1000
setting USER_CHUNK_MALLOC_MAX default 8000000

# If this option is enabled APIs to set the above limits at run time are added;
# without this the hardwired (compile time) limits will be used.
option SET_USER_LIMITS requires USER_LIMITS

# All of the following options relate to code capabilities for
# processing image data before creating a PNG or after reading one.
# You can remove these capabilities safely and still be PNG
# conformant, however the library that results is still non-standard.
# See the comments above about how to change options and settings.

# READ/WRITE tranform support
#
# The internal TRANSFORM_MECH options are used to turn on (or off) the required
# support code for the read and write transforms.  They are off by default,
# switching them on is not a good idea.  Switching them off will cause the build
# to fail if anything is left in which depends on the transform support.
option TRANSFORM_MECH disabled

# READ options
#
# WARNING: in libpng 1.5 maintained configuration compatibility with earlier
# versions.  In some cases turning off an option turned off other options, in
# others it was ineffective unless dependent options were also turned off.
# Libpng 1.6 changes this: in general if you turn off an option that affects
# APIs it stays off and simply disables APIs that depend on it.
#
# As a result if you simply port the libpng 1.5 configuration to libpng 1.6 you
# will probably see build failures due to missing APIs.  Fixing these failures
# requires some, perhaps considerable, knowledge of what your libpng using
# applications are doing, fortunately there is no great reason for you to move
# to libpng 1.6; the new interfaces in 1.6 will take several years to become
# popular.

option READ enables SET_OPTION

# Disabling READ_16BIT does not disable reading 16-bit PNG files, but it
# forces them to be chopped down to 8-bit, and disables any 16-bit
# processing after that has happened.  You need to be sure to enable
# READ_SCALE_16_TO_8 or READ_STRIP_16_TO_8 when you disable READ_16BIT for
# this to work properly.  You should disable the other option if you need to
# ensure a particular conversion (otherwise the app can chose.)

option READ_16BIT requires READ enables 16BIT

option READ_TRANSFORMS requires READ
= NO_READ_TRANSFORMS READ_TRANSFORMS_NOT_SUPPORTED

option READ_QUANTIZE requires READ_TRANSFORMS enables TRANSFORM_MECH

# Read gamma handling.  Gamma processing is a core part of libpng and many of
# the capabilities are dependent on libpng performing gamma correction.
#
# In libpng 1.6 disabling gamma processing (setting PNG_NO_READ_GAMMA)
# consistently disables those parts of the API that depend on it.  Prior to
# 1.6.0 this was not true; the results were unpredictable and varied between
# releases.
#
# If you disable gamma processing and your program no longer compiles you need
# to ask whether you really need the APIs that are missing.  If you do then you
# almost certainly need the gamma processing.
#
# If you handle gamma issues outside libpng then you do not need the libpng
# gamma processing; and it is an enormous waste of space.  You just need to
# remove the use of libpng APIs that depend on it.
option READ_GAMMA requires READ_TRANSFORMS, READ_gAMA, READ_sRGB,
   enables TRANSFORM_MECH, READ_SCALE_16_TO_8, READ_EXPAND, SETTING

option READ_ALPHA_MODE requires READ_TRANSFORMS, READ_GAMMA, READ_BACKGROUND
option READ_BACKGROUND requires READ_TRANSFORMS, READ_STRIP_ALPHA, READ_GAMMA,
   READ_tRNS enables TRANSFORM_MECH
option READ_BGR requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_EXPAND_16 requires READ_TRANSFORMS, READ_16BIT, READ_EXPAND,
   enables TRANSFORM_MECH
option READ_EXPAND requires READ_TRANSFORMS, READ_tRNS enables TRANSFORM_MECH
option READ_FILLER requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_GRAY_TO_RGB requires READ_TRANSFORMS, READ_EXPAND,
   enables TRANSFORM_MECH
option READ_INVERT_ALPHA requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_INVERT requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_PACK requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_PACKSWAP requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_RGB_TO_GRAY requires READ_TRANSFORMS, READ_GAMMA,
   enables COLORSPACE, TRANSFORM_MECH, READ_SCALE_16_TO_8
option READ_SCALE_16_TO_8 requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_SHIFT requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_STRIP_16_TO_8 requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_STRIP_ALPHA requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_SWAP_ALPHA requires READ_TRANSFORMS enables TRANSFORM_MECH
option READ_SWAP requires READ_TRANSFORMS, READ_16BIT enables TRANSFORM_MECH
option READ_USER_TRANSFORM requires READ_TRANSFORMS enables TRANSFORM_MECH

# You can define PNG_NO_PROGRESSIVE_READ if you don't do progressive reading.
option PROGRESSIVE_READ requires READ
option SEQUENTIAL_READ requires READ

# Added to 1.7.0: png_read_image now requires the deinterlace code
option READ_IMAGE requires SEQUENTIAL_READ READ_INTERLACING

# This is not talking about reading interlaced PNG files, it is talking about
# libpng support to 'widen' the interlaced passes to the full row width.  If
# you take the rows libpng provides and expand them yourself you do not need
# this code.
option READ_INTERLACING requires READ

option READ_COMPOSITE_NODIV requires READ
= NO_READ_COMPOSITE_NODIV NO_READ_COMPOSITED_NODIV

# Inch conversions

option INCH_CONVERSIONS
= INCH_CONVERSIONS INCH_CONVERSIONS

# API to build a grayscale palette
# NOTE: this is not used internally by libpng at present.

option BUILD_GRAYSCALE_PALETTE

# WRITE options

option WRITE enables WRITE_INT_FUNCTIONS

# Disabling WRITE_16BIT prevents 16-bit PNG files from being
# generated.
option WRITE_16BIT requires WRITE enables 16BIT

option WRITE_TRANSFORMS requires WRITE
= NO_WRITE_TRANSFORMS WRITE_TRANSFORMS_NOT_SUPPORTED

option WRITE_SHIFT requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_PACK requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_BGR requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_SWAP requires WRITE_TRANSFORMS, WRITE_16BIT enables TRANSFORM_MECH
option WRITE_PACKSWAP requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_INVERT requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_FILLER requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_SWAP_ALPHA requires WRITE_TRANSFORMS enables TRANSFORM_MECH
option WRITE_INVERT_ALPHA requires WRITE_TRANSFORMS
option WRITE_USER_TRANSFORM requires WRITE_TRANSFORMS enables TRANSFORM_MECH

# This just disables the code within libpng to implement image interlacing on
# write; the app can still write interlaced images by doing it itself.
option WRITE_INTERLACING requires WRITE

# The following is no longer implemented:
option WRITE_WEIGHTED_FILTER requires WRITE

option WRITE_FLUSH requires WRITE

# Note: these can be turned off explicitly if not required by the
# apps implementing the user transforms
option USER_TRANSFORM_PTR if READ_USER_TRANSFORM, WRITE_USER_TRANSFORM
option USER_TRANSFORM_INFO if READ_USER_TRANSFORM, WRITE_USER_TRANSFORM

# This enables API to set compression parameters for compressing
# non-IDAT chunks (zTXt, iTXt, iCCP, and unknown chunks).  This feature
# was added at libpng-1.5.3.
option WRITE_CUSTOMIZE_ZTXT_COMPRESSION requires WRITE
option WRITE_CUSTOMIZE_COMPRESSION requires WRITE

# Any chunks you are not interested in, you can undef here.  The
# ones that allocate memory may be expecially important (hIST,
# tEXt, zTXt, tRNS, pCAL).  Others will just save time and make png_info
# a bit smaller.

# The size of the png_text structure changed in libpng-1.0.6 when
# iTXt support was added.  iTXt support was turned off by default through
# libpng-1.2.x, to support old apps that malloc the png_text structure
# instead of calling png_set_text() and letting libpng malloc it.  It
# was turned on by default in libpng-1.4.0.

option READ_ANCILLARY_CHUNKS requires READ
# PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED is deprecated.
= NO_READ_ANCILLARY_CHUNKS READ_ANCILLARY_CHUNKS_NOT_SUPPORTED

option WRITE_ANCILLARY_CHUNKS requires WRITE
# PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED is deprecated.
= NO_WRITE_ANCILLARY_CHUNKS WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED

# These options disable *all* the text chunks if turned off
option TEXT disabled
option READ_TEXT requires READ_ANCILLARY_CHUNKS enables TEXT disabled
option WRITE_TEXT requires WRITE_ANCILLARY_CHUNKS enables TEXT disabled

# Moved to pnglibconf.h at libpng-1.5.0
# Feature support: in 1.4 this was in pngconf.h, but the following
# features have no affect on the libpng API.  Add library
# only features to the end of this list.  Add features that
# affect the API above.  (Note: the list of chunks follows
# the library-only settings.)
#
# BUILD TIME ONLY OPTIONS
#   These options do not affect the API but rather alter how the
#   API is implemented, they get recorded in pnglibconf.h, but
#   can't be changed by the application.

# Colorspace support (enabled as required); just the support for colorant
# information.  Gamma support, likewise, is just support for the gamma
# information, READ_GAMMA is required for gamma transformations (so it
# is possible to read PNG gamma without enabling all the libpng transform
# code - do this for applications that do their own gamma processing)
#
# As of 1.6.0 COLORSPACE is only useful if the application processes the
# information; this is because the library does not do any colorspace
# processing, it just validates the data in the PNG file.

option GAMMA disabled
option COLORSPACE enables GAMMA disabled

# When an ICC profile is read, or png_set, it will be checked for a match
# against known sRGB profiles if the sRGB handling is enabled.  The
# PNG_sRGB_PROFILE_CHECKS setting controls how much work is done during the
# check:
#
# -1: Don't do any sRGB profile checking.
#
#  0: Just validate the profile MD5 signature if present, otherwise use
#     the checks in option 1.
#
#  1: Additionally check the length, intent and adler32 checksum of the
#     actual data.   If enabled this will reject known profiles that have
#     had the rendering intent in the header changed as well as other edits
#     done without updating the checksum.  See the discussion below.
#
#  2: Additionally checksum all the data using the ethernet CRC32 algorithm.
#     This makes it more difficult to fake profiles and makes it less likely
#     to get a false positive on profiles with no signature, but is probably
#     just a waste of time since all currently approved ICC sRGB profiles have
#     a secure MD5 signature.
#
# The rendering intent.  An ICC profile stores an intended rendering intent,
# but does not include the value in the signature.  The intent is documented
# as the intent that should be used when combining two profiles.  The sRGB
# profile is intended, however, to be used with any of the four defined intents.
# For this reason the sRGB chunk includes an 'intent' to be used when displaying
# the image (intent is really a property of the image not the profile.)
#
# Unfortunately the iCCP chunk does not.  It may therefore be that some
# applications modify the intent in profiles (including sRGB profiles) to work
# round this problem.  Selecting an option other than option '0' will cause such
# modified profiles to be rejected.
#
# Security.  The use of Adler32 and CRC32 checksums does not help significantly
# with any security issues.  It is relatively easy to produce arbitrary profiles
# with the required checksums on current computer systems.  Nevertheless
# security does not seem to be an issue because the only consequence of a false
# positive is a false assertion that the profile is an sRGB profile.  This might
# be used to hide data from libpng using applications, but it doesn't seem
# possible to damage them.

setting sRGB_PROFILE_CHECKS default 2

# Artificially align memory - the code typically aligns to 8 byte
# boundaries if this is switched on, it's a small waste of space
# but can help (in theory) on some architectures.  Only affects
# internal structures.  Added at libpng 1.4.0

option ALIGNED_MEMORY

# Other defines for things like memory and the like can go here.

# BUILD TIME SETTINGS
# Like build time options these do not affect the API, but they
# may be useful to applications because they record details of
# how the API will behave particularly with regard to overall
# accuracy.

# This controls how fine the quantizing gets.  As this allocates
# a largish chunk of memory (32K), those who are not as concerned
# with quantizing quality can decrease some or all of these.

setting QUANTIZE_RED_BITS default 5
setting QUANTIZE_GREEN_BITS default 5
setting QUANTIZE_BLUE_BITS default 5

# LEGACY: this used to control the precision of 16-bit gamma operations when the
# output was only 8 bits.  It is left in for background compatibility but it
# does nothing.

setting MAX_GAMMA_8 default 11

# This controls how much a difference in gamma libpng will ignore; if a gamma
# convertion is greater than this it will be done, if less it will be skipped.
#
# Prior to 1.7.0 this value was somewhat large; 5%.  In 1.7.0 it has been set to
# 1%.  The logic for this is that human vision can perceive about a 1% change in
# luminance, so if a user were to compare an image with the correct gamma
# correction against the libpng output we would want libpng to be within 1% of
# the correct values for all pixel values x, [0..1], so:
#
#             x
#      --------------- = 1.01
#      x^(1+threshold)
#
#      x^-threshold = 1.01
#      -threshold.log(x) = log(1.01)
#
#                  log(1.01)
#      threshold = ---------
#                   -log(x)
#
# The threshold goes down as 'x' goes down.  For linear 16-bit values the
# threshold is under 0.1% for the smallest value (1/65535), for linear 8-bit
# values it is under 1%.  It gets considerably smaller for gamma encoded values.
#
# However it is pointless to place demands on one part of the pipeline that
# other parts cannot meet.  The 1.7 pipeline uses 16-bit linear arithmetic,
# therefore 1% resolution is only met with a pixel value (x) of 100/65535.  The
# corresponding value of 'threshold' is 0.15%, hence:

setting GAMMA_THRESHOLD_FIXED default 153

# Internally libpng 1.7 uses a gamma table lookup to cache results.  Because the
# LUT is excessively large for 16-bit linear values the algorithm uses a
# partitioned table (in fact it's a classic floating point LUT) to achieve a
# given accuracy in the calculations.  Each table has 2^b entries, where b is
# the number of bits of the value used to index the LUT.  The table is indexed
# by the high bits [2..2+b] (where '1' is the highest bit) of the value, so the
# accuracy in the linear case is (worst case) 1/(1+1/2^b).
#
# IN FACT a 'b' of 6 is almost certainly adequate; accuracy of 1/64, HOWEVER,
# received wisdom is that 1% accuracy is required (show me a paper that proves
# this by experiment; the only information I have found suggests to me that 1/60
# is the peak possible for a typical human being.)
#
# The default table size is controlled by the following option, this is the
# number of bits in the table for *linear* input multiplied by 100, so the
# default is 6.65 and 2^6.65 is just over 100, giving the desired .5% accuracy
# in the linear domain.  When the input is not linear an appropriate adjustment
# is made by dividing the value by the encoding gamma; much more accuracy is
# required from the gamma encoded input to give +/-.5% accuracy in the linear
# domain.  Note that the default exceeds the accuracy of 8-bit gamma encoded
# values, but that is because 8-bit gamma encoded values are not sufficiently
# accurate to represent the 1% over 100:1 range assumed for human vision
# (9-bits to represent 463 values, are required).

setting DEFAULT_GAMMA_ACCURACY default 665

# Precision to use when converting a floating point value to a PNG
# extension format string in an sCAL chunk (only relevant if the
# floating point API is enabled)

setting sCAL_PRECISION default 5

# This used to control the size of the IDAT chunks on write and the size of the
# compression buffer used internally.  It now solely controls the size of the
# written IDAT chunks.  It can be any (zlib) uInt value, however this amount of
# data has to be buffered on write so it is recommended that a smaller size be
# used unless saving the 12-byte chunk overhead is necessary.

setting ZBUF_SIZE default 4096

# This is the size of the decompression buffer used when counting or checking
# the decompressed size of an LZ stream from a compressed ancilliary chunk; the
# decompressed data is never used so a different size may be optimal.  This size
# was determined using contrib/libtests/timepng.c with compressed zTXt data
# around 11MByte in size.  Slight speed improvements (up to about 14% in
# timepng) can be achieved by very large increases (to 32kbyte) on regular data,
# but highly compressible data shows only around 2% improvement.   The size is
# chosen to minimize the effects of DoS attacks based on using very large
# amounts of highly compressible data.

setting INFLATE_BUF_SIZE default 1024

# This is the amount of IDAT data that the sequential reader will process at one
# time.  The setting does not affect the size of IDAT chunks read, just the
# amount read at once.  Neither does it affect the progressive reader, which
# processes just the amount of data the application gives it.
#
# The sequential reader will read IDAT chunks up to this limit, or the end of
# the chunks, before decompressing the next row.  The value should be chosen to
# optimize the PNG data read speed, it has no significant effect on anything
# else.

setting IDAT_READ_SIZE default 4096

# Ancillary chunks
chunk bKGD
chunk cHRM enables COLORSPACE
chunk gAMA enables GAMMA
chunk hIST
chunk iCCP enables COLORSPACE, GAMMA
chunk iTXt
chunk oFFs
chunk pCAL
chunk pHYs
chunk sBIT
chunk sCAL
chunk sPLT
chunk sRGB enables COLORSPACE, GAMMA, SET_OPTION
chunk tEXt
chunk tIME
chunk tRNS
chunk zTXt

# Text handling; add enable options to the read/write possibilities:
option READ_tEXt enables READ_TEXT
option READ_zTXt enables READ_TEXT
option READ_iTXt enables READ_TEXT
option WRITE_tEXt enables WRITE_TEXT
option WRITE_zTXt enables WRITE_TEXT
option WRITE_iTXt enables WRITE_TEXT

# This only affects support of the optional PLTE chunk in RGB and RGBA
# images.  Notice that READ_ANCILLARY_CHUNKS therefore disables part
# of the regular chunk reading too.

option READ_OPT_PLTE requires READ_ANCILLARY_CHUNKS

# Unknown chunk handling
#
# 'UNKNOWN_CHUNKS' is a global option to disable all unknown chunk handling on
# read or write; everything else below requires it (directly or indirectly).
option UNKNOWN_CHUNKS

# There are three main options to control the ability to read and write unknown
# chunks.  If either read option is turned on then unknown chunks will be read,
# otherwise they are skipped.  If the write option is turned on unknown chunks
# set by png_set_unknown_chunks will be written otherwise it is an error to call
# that API on a write struct.
option WRITE_UNKNOWN_CHUNKS requires WRITE UNKNOWN_CHUNKS
option WRITE_UNKNOWN_CHUNKS enables STORE_UNKNOWN_CHUNKS

# The first way to read user chunks is to have libpng save them for a later call
# to png_get_unknown_chunks, the application must call
# png_set_keep_unknown_chunks to cause this to actually happen (see png.h)
option SAVE_UNKNOWN_CHUNKS requires READ SET_UNKNOWN_CHUNKS HANDLE_AS_UNKNOWN
option SAVE_UNKNOWN_CHUNKS enables READ_UNKNOWN_CHUNKS STORE_UNKNOWN_CHUNKS

# The second approach is to use an application provided callback to process the
# chunks, the callback can either handle the chunk entirely itself or request
# that libpng store the chunk for later retrieval via png_get_unknown_chunks.
#
# NOTE: If STORE_UNKNOWN_CHUNKS is not enabled (which is the default if
# both SAVE_UNKNOWN_CHUNKS and WRITE_UNKNOWN_CHUNKS are disabled) then a
# 0 result from the callback will be ignored because no support for saving
# unknown chunks has been compiled in.  The normal symptom is that your app
# fails to compile because png_get_unknown_chunks is no longer defined in png.h.
# If you encounter this issue simply enable STORE_UNKNOWN_CHUNKS in your build.
#
# Note that there is no 'WRITE_USER_CHUNKS' so the USER_CHUNKS option is always
# the same as READ_USER_CHUNKS at present
option READ_USER_CHUNKS requires READ, UNKNOWN_CHUNKS
option READ_USER_CHUNKS enables READ_UNKNOWN_CHUNKS, USER_CHUNKS

# Two further options are provided to allow detailed control of the handling.
# The first enables png_set_keep_unknown_chunks; this allows the default to be
# changed from discarding unknown chunks and allows per-chunk control.  This is
# required to use the SAVE_UNKNOWN_CHUNKS option.  If enabled this option also
# applies to write (see png.h), otherwise the write API simply writes all the
# chunks it is given.
#
# The second option extends the unknown handling to allow known chunks to be
# handled as though they were unknown.  This option doesn't change any APIs, it
# merely turns on the code to check known as well as unknown chunks.
#
# This option no longer affects the write code.  It can be safely disabled and
# will prevent applications stopping libpng reading known chunks.
option SET_UNKNOWN_CHUNKS requires UNKNOWN_CHUNKS
option HANDLE_AS_UNKNOWN requires SET_UNKNOWN_CHUNKS READ

# The following options are derived from the above and should not be turned on
# explicitly.
option READ_UNKNOWN_CHUNKS requires READ UNKNOWN_CHUNKS disabled
option STORE_UNKNOWN_CHUNKS requires UNKNOWN_CHUNKS disabled

option CONVERT_tIME requires WRITE_ANCILLARY_CHUNKS
# The "tm" structure is not supported on WindowsCE

@#ifdef _WIN32_WCE
@#   define PNG_NO_CONVERT_tIME
@#endif

# Write filter options:
#
#  WRITE_FILTER
#     Enables code to do PNG row filtering on write.  If not enabled rows will
#     be written without filtering; the 'NONE' filter.  This enables the
#     png_set_filter interface allowing the application to select the filter
#     used for each row.
#
#  SELECT_FILTER_HEURISTICALLY
#     Enables code to cause libpng to choose a filter from a set passed to
#     png_set_filter.  Without this code libpng just chooses the first filter in
#     the list if multiple are given.
#
#  SELECT_FILTER_METHODICALLY
#     Enables code to try all the filters in the list passed to png_set_filter
#     and choose the one which results in the least number of compressed bytes
#     added by the current row.
#
#  See png.h for more description of these options.
option WRITE_FILTER requires WRITE
option SELECT_FILTER_HEURISTICALLY requires WRITE_FILTER enables SET_OPTION
option SELECT_FILTER_METHODICALLY requires WRITE_FILTER enables SET_OPTION

# added at libpng-1.5.4

option WRITE_OPTIMIZE_CMF requires WRITE

option READ_COMPRESSED_TEXT disabled
option READ_iCCP enables READ_COMPRESSED_TEXT
option READ_iTXt enables READ_COMPRESSED_TEXT
option READ_zTXt enables READ_COMPRESSED_TEXT

option WRITE_COMPRESSED_TEXT disabled
option WRITE_iCCP enables WRITE_COMPRESSED_TEXT
option WRITE_iTXt enables WRITE_COMPRESSED_TEXT
option WRITE_zTXt enables WRITE_COMPRESSED_TEXT

# Turn this off to disable png_read_png() and png_write_png() and
# leave the row_pointers member out of the info structure.

option INFO_IMAGE disabled
option READ_PNG requires READ_IMAGE READ_TRANSFORMS enables INFO_IMAGE
option WRITE_PNG requires WRITE WRITE_TRANSFORMS enables INFO_IMAGE

# There are four options here, two each for read and write.  By default they are
# all switched on.
#
# 1) {READ,WRITE}_CHECK_FOR_INVALID_INDEX: checks PNG colormap data on read or
#    write to ensure it does not contain out-of-range palette index values.
#    Disabled by -DPNG_NO_CHECK_FOR_INVALID_INDEX
#
# 2) {READ,WRITE}_GET_PALETTE_MAX: returns the largest pixel value in a
#    color mapped PNG.  Disabled by -DPNG_NO_GET_PALETTE_MAX
#
# All of this stuff can be removed by "option PALETTE_MAX off" but using
# -DPNG_NO_ defines on the command line just sets the relevant option to
# "disabled", so if you want to *disable* just READ_CHECK_FOR_INVALID_INDEX (for
# example) you need both -DPNG_NO_CHECK_FOR_INVALID_INDEX *and*
# -DPNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
option PALETTE_MAX disabled enables TRANSFORM_MECH

option CHECK_FOR_INVALID_INDEX,
   enables READ_CHECK_FOR_INVALID_INDEX WRITE_CHECK_FOR_INVALID_INDEX
option READ_CHECK_FOR_INVALID_INDEX requires READ disabled enables PALETTE_MAX
option WRITE_CHECK_FOR_INVALID_INDEX requires WRITE disabled enables PALETTE_MAX

option GET_PALETTE_MAX enables READ_GET_PALETTE_MAX WRITE_GET_PALETTE_MAX
option READ_GET_PALETTE_MAX requires READ disabled enables PALETTE_MAX
option WRITE_GET_PALETTE_MAX requires WRITE disabled enables PALETTE_MAX

# Simplified API options (added at libpng-1.6.0)
#  In libpng 1.6.8 the handling of these options was changed to used 'requires'
#  throughout, so that disabling some of the low level support always disables
#  the base simplified read/write API.  This much simplifies the handling and
#  makes 'everything = off' work in a more intuitive way.  It eliminates a
#  previously reported feature that APIs previously enabled by the simplified
#  API couldn't be turned off without explicitly turning off the simplified
#  APIs.
#
# Read:
option SIMPLIFIED_READ,
   requires SEQUENTIAL_READ, READ_TRANSFORMS, SETJMP, BENIGN_ERRORS,
      READ_EXPAND, READ_16BIT, READ_EXPAND_16, READ_SCALE_16_TO_8,
      READ_RGB_TO_GRAY, READ_ALPHA_MODE, READ_BACKGROUND, READ_STRIP_ALPHA,
      READ_FILLER, READ_SWAP, READ_PACK, READ_GRAY_TO_RGB, READ_GAMMA,
      READ_tRNS, READ_bKGD, READ_gAMA, READ_cHRM, READ_sRGB, READ_sBIT,
      READ_INTERLACING

# AFIRST and BGR read options:
#  Prior to libpng 1.6.8 these were disabled but switched on if the low level
#  libpng routines that do the swaps were enabled.  This worked but was
#  confusing.  In libpng 1.6.8 the options were changed to simple 'requires'
#  and are enabled by default.  This should work the same way in practice.
option SIMPLIFIED_READ_AFIRST enables FORMAT_AFIRST,
   requires SIMPLIFIED_READ READ_SWAP_ALPHA

option SIMPLIFIED_READ_BGR enables FORMAT_BGR,
   requires SIMPLIFIED_READ READ_BGR

# Write:
option SIMPLIFIED_WRITE,
   requires WRITE, SETJMP, WRITE_SWAP, WRITE_PACK,
      WRITE_tRNS, WRITE_gAMA, WRITE_sRGB, WRITE_cHRM

# 1.6.22: allow simplified write without stdio support:
option SIMPLIFIED_WRITE_STDIO requires SIMPLIFIED_WRITE STDIO

option SIMPLIFIED_WRITE_AFIRST enables FORMAT_AFIRST,
   requires SIMPLIFIED_WRITE WRITE_SWAP_ALPHA

option SIMPLIFIED_WRITE_BGR enables FORMAT_BGR,
   requires SIMPLIFIED_WRITE WRITE_BGR

# Formats:
option FORMAT_AFIRST disabled
option FORMAT_BGR disabled
